// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const addGuildToConfig = `-- name: AddGuildToConfig :exec
UPDATE guild_configs
SET tibia_guilds = array_append(tibia_guilds, $2::text), updated_at = NOW()
WHERE guild_id = $1 AND NOT ($2::text = ANY(COALESCE(tibia_guilds, '{}')))
`

type AddGuildToConfigParams struct {
	GuildID    string
	TibiaGuild string
}

func (q *Queries) AddGuildToConfig(ctx context.Context, arg AddGuildToConfigParams) error {
	_, err := q.db.Exec(ctx, addGuildToConfig, arg.GuildID, arg.TibiaGuild)
	return err
}

const batchTouchPlayers = `-- name: BatchTouchPlayers :exec
UPDATE players SET updated_at = NOW() WHERE name = ANY($1::text[])
`

func (q *Queries) BatchTouchPlayers(ctx context.Context, names []string) error {
	_, err := q.db.Exec(ctx, batchTouchPlayers, names)
	return err
}

const deleteGuildConfig = `-- name: DeleteGuildConfig :exec
DELETE FROM guild_configs WHERE guild_id = $1
`

func (q *Queries) DeleteGuildConfig(ctx context.Context, guildID string) error {
	_, err := q.db.Exec(ctx, deleteGuildConfig, guildID)
	return err
}

const deleteOldPlayers = `-- name: DeleteOldPlayers :execresult
DELETE FROM players WHERE world = $1 AND updated_at < NOW() - $2::interval
`

type DeleteOldPlayersParams struct {
	World     string
	Threshold pgtype.Interval
}

func (q *Queries) DeleteOldPlayers(ctx context.Context, arg DeleteOldPlayersParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteOldPlayers, arg.World, arg.Threshold)
}

const getGuildConfig = `-- name: GetGuildConfig :one
SELECT guild_id, world, tibia_guilds, updated_at FROM guild_configs WHERE guild_id = $1
`

func (q *Queries) GetGuildConfig(ctx context.Context, guildID string) (GuildConfig, error) {
	row := q.db.QueryRow(ctx, getGuildConfig, guildID)
	var i GuildConfig
	err := row.Scan(
		&i.GuildID,
		&i.World,
		&i.TibiaGuilds,
		&i.UpdatedAt,
	)
	return i, err
}

const getOfflinePlayers = `-- name: GetOfflinePlayers :many
SELECT name, level FROM players WHERE world = $1 AND name != ALL($2::text[])
`

type GetOfflinePlayersParams struct {
	World       string
	OnlineNames []string
}

type GetOfflinePlayersRow struct {
	Name  string
	Level int32
}

func (q *Queries) GetOfflinePlayers(ctx context.Context, arg GetOfflinePlayersParams) ([]GetOfflinePlayersRow, error) {
	rows, err := q.db.Query(ctx, getOfflinePlayers, arg.World, arg.OnlineNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOfflinePlayersRow
	for rows.Next() {
		var i GetOfflinePlayersRow
		if err := rows.Scan(&i.Name, &i.Level); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayersLevels = `-- name: GetPlayersLevels :many
SELECT name, level FROM players WHERE world = $1
`

type GetPlayersLevelsRow struct {
	Name  string
	Level int32
}

func (q *Queries) GetPlayersLevels(ctx context.Context, world string) ([]GetPlayersLevelsRow, error) {
	rows, err := q.db.Query(ctx, getPlayersLevels, world)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayersLevelsRow
	for rows.Next() {
		var i GetPlayersLevelsRow
		if err := rows.Scan(&i.Name, &i.Level); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorldsMap = `-- name: GetWorldsMap :many
SELECT guild_id, world, tibia_guilds FROM guild_configs
`

type GetWorldsMapRow struct {
	GuildID     string
	World       string
	TibiaGuilds []string
}

func (q *Queries) GetWorldsMap(ctx context.Context) ([]GetWorldsMapRow, error) {
	rows, err := q.db.Query(ctx, getWorldsMap)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorldsMapRow
	for rows.Next() {
		var i GetWorldsMapRow
		if err := rows.Scan(&i.GuildID, &i.World, &i.TibiaGuilds); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeGuildFromConfig = `-- name: RemoveGuildFromConfig :exec
UPDATE guild_configs
SET tibia_guilds = array_remove(tibia_guilds, $2::text), updated_at = NOW()
WHERE guild_id = $1
`

type RemoveGuildFromConfigParams struct {
	GuildID    string
	TibiaGuild string
}

func (q *Queries) RemoveGuildFromConfig(ctx context.Context, arg RemoveGuildFromConfigParams) error {
	_, err := q.db.Exec(ctx, removeGuildFromConfig, arg.GuildID, arg.TibiaGuild)
	return err
}

const saveGuildWorld = `-- name: SaveGuildWorld :exec
INSERT INTO guild_configs (guild_id, world, updated_at)
VALUES ($1, $2, NOW())
ON CONFLICT (guild_id) DO UPDATE
SET world = EXCLUDED.world, updated_at = NOW()
`

type SaveGuildWorldParams struct {
	GuildID string
	World   string
}

func (q *Queries) SaveGuildWorld(ctx context.Context, arg SaveGuildWorldParams) error {
	_, err := q.db.Exec(ctx, saveGuildWorld, arg.GuildID, arg.World)
	return err
}

const upsertPlayerLevel = `-- name: UpsertPlayerLevel :exec
INSERT INTO players (name, level, world, updated_at)
VALUES ($1, $2, $3, NOW())
ON CONFLICT (name) DO UPDATE
SET level = EXCLUDED.level, world = EXCLUDED.world, updated_at = NOW()
`

type UpsertPlayerLevelParams struct {
	Name  string
	Level int32
	World string
}

func (q *Queries) UpsertPlayerLevel(ctx context.Context, arg UpsertPlayerLevelParams) error {
	_, err := q.db.Exec(ctx, upsertPlayerLevel, arg.Name, arg.Level, arg.World)
	return err
}
