// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const batchTouchPlayers = `-- name: BatchTouchPlayers :exec
UPDATE players SET updated_at = NOW() WHERE name = ANY($1::text[])
`

func (q *Queries) BatchTouchPlayers(ctx context.Context, names []string) error {
	_, err := q.db.Exec(ctx, batchTouchPlayers, names)
	return err
}

const deleteGuildConfig = `-- name: DeleteGuildConfig :exec
DELETE FROM guild_configs WHERE guild_id = $1
`

func (q *Queries) DeleteGuildConfig(ctx context.Context, guildID string) error {
	_, err := q.db.Exec(ctx, deleteGuildConfig, guildID)
	return err
}

const deleteOldPlayers = `-- name: DeleteOldPlayers :execresult
DELETE FROM players WHERE world = $1 AND updated_at < NOW() - $2::interval
`

type DeleteOldPlayersParams struct {
	World     string
	Threshold pgtype.Interval
}

func (q *Queries) DeleteOldPlayers(ctx context.Context, arg DeleteOldPlayersParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteOldPlayers, arg.World, arg.Threshold)
}

const getPlayersLevels = `-- name: GetPlayersLevels :many
SELECT name, level FROM players WHERE world = $1
`

type GetPlayersLevelsRow struct {
	Name  string
	Level int32
}

func (q *Queries) GetPlayersLevels(ctx context.Context, world string) ([]GetPlayersLevelsRow, error) {
	rows, err := q.db.Query(ctx, getPlayersLevels, world)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayersLevelsRow
	for rows.Next() {
		var i GetPlayersLevelsRow
		if err := rows.Scan(&i.Name, &i.Level); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorldsMap = `-- name: GetWorldsMap :many
SELECT guild_id, world FROM guild_configs
`

type GetWorldsMapRow struct {
	GuildID string
	World   string
}

func (q *Queries) GetWorldsMap(ctx context.Context) ([]GetWorldsMapRow, error) {
	rows, err := q.db.Query(ctx, getWorldsMap)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorldsMapRow
	for rows.Next() {
		var i GetWorldsMapRow
		if err := rows.Scan(&i.GuildID, &i.World); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveGuildWorld = `-- name: SaveGuildWorld :exec
INSERT INTO guild_configs (guild_id, world, updated_at)
VALUES ($1, $2, NOW())
ON CONFLICT (guild_id) DO UPDATE
SET world = EXCLUDED.world, updated_at = NOW()
`

type SaveGuildWorldParams struct {
	GuildID string
	World   string
}

func (q *Queries) SaveGuildWorld(ctx context.Context, arg SaveGuildWorldParams) error {
	_, err := q.db.Exec(ctx, saveGuildWorld, arg.GuildID, arg.World)
	return err
}

const upsertPlayerLevel = `-- name: UpsertPlayerLevel :exec
INSERT INTO players (name, level, world, updated_at)
VALUES ($1, $2, $3, NOW())
ON CONFLICT (name) DO UPDATE
SET level = EXCLUDED.level, world = EXCLUDED.world, updated_at = NOW()
`

type UpsertPlayerLevelParams struct {
	Name  string
	Level int32
	World string
}

func (q *Queries) UpsertPlayerLevel(ctx context.Context, arg UpsertPlayerLevelParams) error {
	_, err := q.db.Exec(ctx, upsertPlayerLevel, arg.Name, arg.Level, arg.World)
	return err
}
